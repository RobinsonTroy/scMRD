---
title: "scMRD_preprocessing_synthetic_multiplexing"
author: "TR"
date: "2023-05-02"
output: html_document
---

Here you'll find code on how we processed the 5 AML samples for synthetic multiplexing. In the "scMRD_synthetic_multiplexing.Rmd" file, the samples are named A-E for the purpose of simplicity. The .h5 files in dbGAP have the original nomenclature, so here is a key:

Sample A: RC74
Sample B: GR31
Sample C: KS48
Sample D: DA55
Sample E: LK73

In this example, we are processing RC74 (Sample A). 
```{r}

library(tidyverse)
library(BSgenome.Hsapiens.UCSC.hg19)
library(umap)
library(pals)
library(cluster)
library(ClusterR)
library(pheatmap)
library(ggplot2)
library(RColorBrewer)
library(cowplot)
library(VariantAnnotation)
library(GenomicRanges)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(tidyverse)

file<- c("/Users/robinst1/Desktop/MSKCC/Levine_Lab/Data/R/scDNA_analysis/WX_scDNA_h5_files/WX_RC74.dna+protein.h5")

```

Load in the manually curated transcript ID table and annotation key. More detailed information for generating the transcript ID table can be found here: https://bowmanr.github.io/scDNA_myeloid/hdf5-and-loom-input.html (this is also overall an excellent resource for scDNA+protein analysis). 
```{r,variant selection setup,message=FALSE,warning=FALSE}


annotation_key <-read.csv("/Users/robinst1/Desktop/MSKCC/Levine_Lab/Data/R/scDNA_analysis/MBio_scDNA_keys/annotation_key_RUNX1C.csv")
banned <-read.csv("/Users/robinst1/Desktop/MSKCC/Levine_Lab/Data/R/scDNA_analysis/MBio_scDNA_keys/banned_list.csv")[,1]
hg19refseq_txdb<-loadDb("/Users/robinst1/Desktop/MSKCC/Levine_Lab/Data/R/scDNA_analysis/MBio_scDNA_keys/hg19refseq_txdb_new.sqlite")

annotation_key%<>%inner_join(VariantAnnotation::select(hg19refseq_txdb,
                                    keys=annotation_key$ccds_id,
                                    columns=c("TXID","TXNAME"),
                                    keytype = "TXNAME"),
                             by=c("ccds_id"="TXNAME"))%>%
                  mutate(TXID=as.character(TXID))

```

Functions to extract/filter NGT and AF matrices from the .h5 file. 
```{r}

read_tapestri_h5_NGT <- function (file, VAF_cutoff = 0.005, GT_cutoff = 20) 
                        {
                            NGT <- rhdf5::h5read(file = file, name = "/assays/dna_variants/layers/NGT")
                            NGT[NGT == 3] <- NA
                            VAF_select <- which(apply(NGT, MARGIN = 1, function(x) {
                                (sum(!is.na(x))/length(x)) * 100 >= GT_cutoff & (sum(x, 
                                    na.rm = TRUE)/(sum(!is.na(x)) * 2)) >= VAF_cutoff
                            }))
                            NGTlim <- rhdf5::h5read(file = file, name = "/assays/dna_variants/layers/NGT", 
                                index = list(VAF_select, NULL))
                            NGTlim[NGTlim == 3] <- NA
                            rownames(NGTlim) <- rhdf5::h5read(file = file, name = "/assays/dna_variants/ca/id", 
                                index = list(VAF_select))
                            colnames(NGTlim) <- rhdf5::h5read(file = file, name = "/assays/dna_variants/ra/barcode")
                            return(NGTlim)
}

quality_filter_NGT <- function (file, NGT, DP_cut = 10, AF_cut = 20, GQ_cut = 20) 
                  {
                      variants <- rhdf5::h5read(file = file, name = "/assays/dna_variants/ca/id")
                      select_variants <- match(rownames(NGT), variants)
                      AF <- rhdf5::h5read(file = file, name = "/assays/dna_variants/layers/AF", 
                          index = list(select_variants, NULL))
                      DP <- rhdf5::h5read(file = file, name = "/assays/dna_variants/layers/DP", 
                          index = list(select_variants, NULL))
                      GQ <- rhdf5::h5read(file = file, name = "/assays/dna_variants/layers/GQ", 
                          index = list(select_variants, NULL))
                      NGT_filter <- data.frame(setNames(data.frame(AF, variants = rownames(NGT)), 
                          c(tidyselect::all_of(colnames(NGT)), "variants")) %>% 
                          tidyr::pivot_longer(cols = !c(variants), names_to = "Cell", 
                              values_to = "AF"), data.frame(DP) %>% tidyr::pivot_longer(cols = tidyselect::everything(), 
                          names_to = "Cell", values_to = "DP") %>% dplyr::select(DP), 
                          data.frame(GQ) %>% tidyr::pivot_longer(cols = tidyselect::everything(), 
                              names_to = "Cell", values_to = "GQ") %>% dplyr::select(GQ), 
                          data.frame(NGT) %>% tidyr::pivot_longer(cols = tidyselect::everything(), 
                              names_to = "Cell", values_to = "NGT") %>% dplyr::select(NGT)) %>% 
                          dplyr::filter(DP >= DP_cut & GQ >= GQ_cut) %>% dplyr::mutate(pass = dplyr::case_when(NGT == 
                          1 & (AF > AF_cut) & (AF < (100 - AF_cut)) ~ "include", 
                          NGT == 1 & ((AF <= AF_cut) | (AF >= (100 - AF_cut))) ~ 
                              "exclude", NGT == 2 & AF >= (100 - AF_cut) ~ "include", 
                          NGT == 2 & AF < (100 - AF_cut) ~ "exclude", NGT == 0 & 
                              AF <= AF_cut ~ "include", NGT == 0 & AF > AF_cut ~ 
                              "exclude", TRUE ~ "other")) %>% dplyr::filter(.data$pass == 
                          "include") %>% tidyr::pivot_wider(id_cols = .data$Cell, 
                          names_from = .data$variants, values_from = .data$NGT)
                      return(NGT_filter)
                  }

 read_tapestri_h5_AF <- function (file)
  {
      AF <- rhdf5::h5read(file = file, name = "/assays/dna_variants/layers/AF")
      rownames(AF) <- rhdf5::h5read(file = file, name = "/assays/dna_variants/ca/id")
      colnames(AF) <- rhdf5::h5read(file = file, name = "/assays/dna_variants/ra/barcode")
     return(AF)
  }

  quality_filter_AF <- function (file, AF, DP_cut = 10, AF_cut = 20, GQ_cut = 30)
                {
                    variants <- rhdf5::h5read(file = file, name = "/assays/dna_variants/ca/id")
                    select_variants <- match(rownames(AF), variants)
                    NGT <- rhdf5::h5read(file = file, name = "/assays/dna_variants/layers/NGT",
                        index = list(select_variants, NULL))
                    DP <- rhdf5::h5read(file = file, name = "/assays/dna_variants/layers/DP",
                        index = list(select_variants, NULL))
                    GQ <- rhdf5::h5read(file = file, name = "/assays/dna_variants/layers/GQ",
                        index = list(select_variants, NULL))
                    NGT_filter <- data.frame(setNames(data.frame(NGT, variants = rownames(AF)),
                        c(tidyselect::all_of(colnames(AF)), "variants")) %>%
                        tidyr::pivot_longer(cols = !c(variants), names_to = "Cell",
                            values_to = "NGT"), data.frame(DP) %>% tidyr::pivot_longer(cols = tidyselect::everything(),
                        names_to = "Cell", values_to = "DP") %>% dplyr::select(DP),
                        data.frame(GQ) %>% tidyr::pivot_longer(cols = tidyselect::everything(),
                            names_to = "Cell", values_to = "GQ") %>% dplyr::select(GQ),
                        data.frame(AF) %>% tidyr::pivot_longer(cols = tidyselect::everything(),
                            names_to = "Cell", values_to = "AF") %>% dplyr::select(AF)) %>%
                        dplyr::filter(DP >= DP_cut & GQ >= GQ_cut) %>% dplyr::mutate(pass = dplyr::case_when(NGT ==
                        1 & (AF > AF_cut) & (AF < (100 - AF_cut)) ~ "include",
                        NGT == 1 & ((AF <= AF_cut) | (AF >= (100 - AF_cut))) ~
                            "exclude", NGT == 2 & AF >= (100 - AF_cut) ~ "include",
                        NGT == 2 & AF < (100 - AF_cut) ~ "exclude", NGT == 0 &
                            AF <= AF_cut ~ "include", NGT == 0 & AF > AF_cut ~
                            "exclude", TRUE ~ "other")) %>%
                        dplyr::filter(.data$pass == "include") %>%
                        tidyr::pivot_wider(id_cols = .data$Cell,
                        names_from = .data$variants, values_from = .data$AF)
                    return(NGT_filter)
               }


```

Read in the numerical genotyping (NGT) matrix from the H5 file, setting the desired cutoffs for mutation VAF (0.1%) and genotyping call rate (20%). This can take some time to load, so it is recommended to do this once and export the NGT as an RDS file for future use. I have previously exported the NGT matrix as an RDS, so I am just loading it here.
```{r}

# NGT<-read_tapestri_h5_NGT(file,
#                           VAF_cutoff = 0.001,
#                           GT_cutoff = 20 )

# saveRDS(NGT, file = "RC74_NGT_scMRD.rds")

NGT <- readRDS(file = "/Users/robinst1/Desktop/MSKCC/Levine_Lab/Data/R/scDNA_analysis/WX/MRD_Manuscript/RC74_NGT_scMRD.rds")

```

Filter the NGT genotypes based on Mission Bio recommended cutoffs.
```{r}

 # filtered_NGT<-quality_filter_NGT(file=file,
 #                                  NGT=NGT,
 #                                  DP_cut=10, 
 #                                  AF_cut=20,
 #                                  GQ_cut=30)
 # 
 # saveRDS(filtered_NGT, file = "RC74_filtered_NGT_scMRD.rds")

filtered_NGT <- readRDS(file = "/Users/robinst1/Desktop/MSKCC/Levine_Lab/Data/R/scDNA_analysis/WX/MRD_Manuscript/RC74_filtered_NGT_scMRD.rds")

```

Extract the allele frequency (AF) matrix from the .h5 file.
```{r,message=FALSE}

 # AF_matrix<- read_tapestri_h5_AF(file)
 # AF_matrix_subset<- AF_matrix[rownames(NGT),]
 # 
 # saveRDS(AF_matrix_subset, file = "RC74_AF_matrix_scMRD.rds")

AF_matrix_subset <- readRDS(file = "/Users/robinst1/Desktop/MSKCC/Levine_Lab/Data/R/scDNA_analysis/WX/MRD_Manuscript/RC74_AF_matrix_scMRD.rds")

```

Extract and filter the AF matrix based on cutoffs described above. 
```{r,message=FALSE}

# filtered_AF <- quality_filter_AF(file=file,
#                                  AF=AF_matrix_subset,
#                                  DP_cut=10,
#                                  AF_cut=20,
#                                  GQ_cut=30)
# 
# saveRDS(filtered_AF, file = "RC74_filtered_AF_scMRD.rds")

filtered_AF <- readRDS(file = "/Users/robinst1/Desktop/MSKCC/Levine_Lab/Data/R/scDNA_analysis/WX/MRD_Manuscript/RC74_filtered_AF_scMRD.rds")

```

Format data and annotate variants using the `GenomicRanges` and `VariantAnnotation` packages.
```{r,message=FALSE, warning=FALSE}

variants <- rhdf5::h5read(file = file, name = "/assays/dna_variants/ca/id") #all variants
select_variants <- setdiff(colnames(filtered_NGT), "Cell") #variants in the NGT (influenced by VAF and GT cutoffs)

SNV_mat <- data.frame(do.call(cbind, rhdf5::h5read(file = file, name = "/assays/dna_variants/ca/"))) %>%
                      dplyr::filter(.data$id %in% tidyselect::all_of(select_variants))%>% 
                      dplyr::mutate(ALT = gsub("\\*","N", .data$ALT))%>% 
                      dplyr::mutate(REF = gsub("\\*","N", .data$REF))%>% 
                      dplyr::mutate(CHROM = paste0("chr",.data$CHROM)) 

SNV_mat$REF <- as(SNV_mat$REF, "DNAStringSet")
SNV_mat$ALT <- as(SNV_mat$ALT, "DNAStringSet")

variant_gRange <- GenomicRanges::makeGRangesFromDataFrame(SNV_mat, 
                  seqnames.field = "CHROM", start.field = "POS", end.field = "POS", 
                  keep.extra.columns = TRUE)
  
variant_gRange$QUERYID <- 1:length(variant_gRange)

all_variants <- VariantAnnotation::locateVariants(query = variant_gRange, 
                                                          subject = hg19refseq_txdb, region = 
                                                          VariantAnnotation::AllVariants()) %>% 
                                                          data.frame()

coding_variants <- VariantAnnotation::predictCoding(query = variant_gRange, 
                                                    subject = hg19refseq_txdb, 
                                                    seqSource = Hsapiens, varAllele = variant_gRange$ALT) %>%
                                                    data.frame()
                                                    coding_variants$LOCATION<- "coding"                                  
    
intronic_variants <- all_variants %>% 
                     plyranges::filter(as.character(.data$LOCATION) != c("coding")) %>%
                     plyranges::filter(as.character(.data$LOCATION) != c("promoter")) %>%
                     dplyr::inner_join(variant_gRange, by = "QUERYID", copy = TRUE)

spliceSite_variants <- all_variants %>% 
                       plyranges::filter(as.character(.data$LOCATION) == c("spliceSite")) %>%
                       dplyr::inner_join(variant_gRange, by = "QUERYID", copy = TRUE)

splice_intronic <- dplyr::bind_rows(intronic_variants, spliceSite_variants)

out <- dplyr::bind_rows(splice_intronic, coding_variants) %>% 
       dplyr::inner_join(annotation_key) %>% 
       dplyr::mutate(AA = case_when(
          .data$CONSEQUENCE == "nonsynonymous" ~ paste0(.data$gene_name, ".", .data$REFAA, .data$PROTEINLOC,.data$VARAA),
          .data$CONSEQUENCE == "frameshift" ~ paste0(.data$gene_name, ".", .data$REFAA, .data$PROTEINLOC,.data$VARAA),
          .data$CONSEQUENCE == "nonsense" ~ paste0(.data$gene_name, ".", .data$REFAA, .data$PROTEINLOC,.data$VARAA),
          .data$CONSEQUENCE == "synonymous" ~ paste0(.data$gene_name, ".", .data$REFAA, .data$PROTEINLOC,.data$VARAA),
          .data$CONSEQUENCE == "not translated" ~ paste0(.data$gene_name, ".not_txl"),
          .data$LOCATION == "spliceSite" ~ paste0(.data$gene_name, ".splice"),
          .data$LOCATION == "intron" ~ paste0(.data$gene_name, ".intron")))

```

Aggregate the annotated variant information, bulk VAF, genotyping call rate, etc. into a dataframe named `final_mutation_info`.
```{r}

final_mutation_info <- data.frame(Bulk_VAF = apply(filtered_NGT %>% 
                                            dplyr::select(!.data$Cell), MARGIN = 2, function(x) {
                                            (sum(x, na.rm = TRUE)/(sum(!is.na(x)) * 2)) * 100
                                            }), GT_call_rate = apply(filtered_NGT %>% dplyr::select(!.data$Cell), 
                                            MARGIN = 2, function(x) {
                                            100 - (sum(is.na(x))/length(x) * 100)
                                            }), id = colnames(filtered_NGT)[colnames(filtered_NGT) !="Cell"])%>% 
                                            dplyr::inner_join(out, by = "id")

head(final_mutation_info)

```

Here we will search for specific variants we expect to find this sample based on bulk sequencing.
```{r}

required_variants <- final_mutation_info%>%
                     filter(grepl("DNMT3A.R882H|IDH1.R132C|RUNX1.123|FLT3.D835H",AA)) %>%
                     filter(Bulk_VAF > 0.5 & GT_call_rate > 50)%>%
                     filter(CONSEQUENCE %in% c("nonsynonymous","frameshift","nonsense")) %>%
                     dplyr::select(id,Bulk_VAF,GT_call_rate,AA)%>% 
                     pull(id)

```

Next we'll determine which cells possess complete genotyping for the `required_variants`. We want to retain these cells throughout downstream analyses and refer to them as `required_cells.`
```{r}

required_cells <- filtered_NGT%>%dplyr::select(Cell,tidyselect::all_of(required_variants))%>%
                  filter(across(.cols = !Cell,.fns = ~ !is.na(.x)))%>%
                  pull(Cell)
```

In a different experimental setting, we may be interested in seeing if there are other variants that are well represented among these required variants. However for our purposes here, we are only interested in the `required_variants.`
```{r}

coding_variants <- final_mutation_info%>%
                   dplyr::filter(!grepl("intronic",AA))%>%
                   dplyr::filter(CONSEQUENCE!="synonymous")%>% #figure out what CONSEQUENCE means here
                   dplyr::filter(GT_call_rate>50)%>%
                   dplyr::filter(Bulk_VAF>0.5)%>%
                   dplyr::select(id,Bulk_VAF,GT_call_rate,AA)%>% #break here to observe full table with mutation information of interest
                   pull(id)

mut_info_annotated <- filtered_NGT%>%
                      pivot_longer(cols=-Cell,names_to="id",values_to = "NGT")%>% #transform length wise
                      filter(!is.na(NGT))%>% #remove poor genotyping calls
                      filter(id%in%coding_variants)%>% #select variants of interest
                      group_by(id)%>% #split data.frame into groups based on the variants of interest variants
                      summarise(required_cell_ratio = mean(all_of(required_cells)%in%Cell))%>% # calculate the proportion of required cells represented in successfully genotyped cells for that variant
                      arrange(desc(required_cell_ratio))%>% # order the data.frame, helpful for plotting later
                      inner_join(final_mutation_info)%>% # join with mutation info
                      filter(!grepl("intronic",AA))%>%  #removes duplicate transcripts
                      mutate(id=factor(id,levels=c(id)))%>% #helpful for plotting later
                      mutate(AA=factor(AA,levels=c(AA)))%>%  #helpful for plotting later
                      mutate(required=ifelse(id%in%required_variants,"Required","Other"))%>%
                      dplyr::select(id,required_cell_ratio,Bulk_VAF,GT_call_rate,AA,required)

```

Select all cells with required variants to generate a complete NGT matrix. 
```{r}

complete_NGT<- filtered_NGT%>%  
                    dplyr::select(Cell,all_of(required_variants))%>%
                    filter(Cell%in%required_cells)

print(dim(complete_NGT))
print(table(is.na(complete_NGT)))

```

There are likely quite a few cells which we can hope to gain information from though, albeit with lower quality information.  We can extract those too and mask them.  The function `active_NGT_filter` below is written for optimal extraction of meaningful cells from a wide range of variants.
```{r}

active_NGT_filter <- function (NGT_filter, variants_of_interest, required_variants, 
                      required_cells, variant_score_cutoff = 0.9, cell_score_cutoff = 0.9, 
                      greedy_scalar = 0.01) 
                  {
                      kept_variants <- setdiff(colnames(NGT_filter), "Cell")
                      kept_cells <- NGT_filter$Cell
                      variants_to_remove <- c()
                      cells_to_remove <- c()
                      variants_to_remove_temp <- data.frame(Variant = "", Score = "")
                      cells_to_remove_temp <- data.frame(Cell = "", Score = "")
                      NGT_long <- NGT_filter %>% tidyr::pivot_longer(cols = !.data$Cell, 
                          names_to = "Variant", values_to = "NGT") %>% dplyr::filter(.data$Variant %in% 
                          tidyselect::all_of(variants_of_interest)) %>% dplyr::mutate(Required_cell = ifelse(.data$Cell %in% 
                          tidyselect::all_of(required_cells), TRUE, FALSE)) %>% 
                          dplyr::mutate(Required_variant = ifelse(.data$Variant %in% 
                              tidyselect::all_of(required_variants), TRUE, FALSE))
                      while (length(variants_to_remove_temp$Variant) != 0 & length(cells_to_remove_temp$Cell) != 
                          0) {
                          variants_to_remove_temp <- NGT_long %>% dplyr::group_by(.data$Variant) %>% 
                              dplyr::summarize(Score = sum(!is.na(.data$NGT))/length(.data$NGT), 
                                  required = sum(.data$Required_variant)) %>% dplyr::filter(!.data$Variant %in% 
                              tidyselect::all_of(required_variants)) %>% dplyr::filter(.data$Score <= 
                              (min(.data$Score) + min(.data$Score) * tidyselect::all_of(greedy_scalar))) %>% 
                              dplyr::filter(.data$Score < tidyselect::all_of(variant_score_cutoff))
                          variants_to_remove <- unique(c(variants_to_remove, variants_to_remove_temp$Variant))
                          cells_to_remove_temp <- NGT_long %>% dplyr::group_by(.data$Cell) %>% 
                              dplyr::summarize(Score = sum(!is.na(.data$NGT))/length(.data$NGT), 
                                  required = sum(.data$Required_cell)) %>% dplyr::filter(!.data$Cell %in% 
                              tidyselect::all_of(required_cells)) %>% dplyr::filter(.data$Score <= 
                              (min(.data$Score) + min(.data$Score) * tidyselect::all_of(greedy_scalar))) %>% 
                              dplyr::filter(.data$Score < tidyselect::all_of(cell_score_cutoff))
                          cells_to_remove <- unique(c(cells_to_remove, cells_to_remove_temp$Cell))
                          NGT_long %<>% dplyr::filter(!.data$Variant %in% tidyselect::all_of(variants_to_remove)) %>% 
                              dplyr::filter(!.data$Cell %in% tidyselect::all_of(cells_to_remove))
                      }
                      NGT_subset <- NGT_long %>% dplyr::filter(!.data$Cell %in% 
                          tidyselect::all_of(cells_to_remove)) %>% dplyr::filter(!.data$Variant %in% 
                          tidyselect::all_of(variants_to_remove)) %>% dplyr::select(.data$Cell, 
                          .data$Variant, .data$NGT) %>% tidyr::pivot_wider(names_from = .data$Variant, 
                          values_from = .data$NGT)
                      return(NGT_subset)
                  }

```

```{r}
maximal_NGT <- scDNA::active_NGT_filter(filtered_NGT,
                                      variants_of_interest=required_variants,
                                      required_variants=required_variants,
                                      required_cells=required_cells,
                                      variant_score_cutoff=0.4,
                                      cell_score_cutoff=0.4,
                                      greedy_scalar=0.005)


```

Compile variant of interest information (i.e. genomic id, VAF, genotyping rate, amino acid change)
```{r}
final_variant_info <- mut_info_annotated%>%
                      filter(id %in% (all_of(colnames(maximal_NGT))))%>%
                      dplyr::select(id,required_cell_ratio,Bulk_VAF,GT_call_rate,AA)%>%
                      arrange(desc(Bulk_VAF))

```

We now have our complete_NGT (full of required_cells only), and our maximal_NGT where we may have low quality information.  Using the function below we can fill in the NA's in the maximal_NGT with that low quality info, and flag cells as either "Complete" or "Other" for downstream processing.
```{r}

generate_lowQC_matrix_TR <- function (NGT_to_fill, complete_NGT, file) 
                            {
                                variants <- rhdf5::h5read(file = file, name = "/assays/dna_variants/ca/id")
                                cells <- rhdf5::h5read(file = file, name = "/assays/dna_variants/ra/barcode")
                                variant_select <- match(setdiff(colnames(NGT_to_fill), "Cell"), 
                                    variants)
                                cell_select <- match(NGT_to_fill %>% dplyr::pull(.data$Cell), 
                                    cells)
                                full_NGT <- setNames(data.frame(Cell = NGT_to_fill %>% dplyr::pull(.data$Cell), 
                                    t(rhdf5::h5read(file = file, name = "/assays/dna_variants/layers/NGT", 
                                        index = list(variant_select, cell_select)))), colnames(NGT_to_fill))
                                full_NGT[full_NGT == 3] <- NA
                                full_NGT %<>% filter(across(.cols = !.data$Cell, .fns = ~!is.na(.x)))
                                full_NGT %<>% dplyr::mutate(Group = dplyr::case_when(.data$Cell %in% 
                                    tidyselect::all_of(complete_NGT$Cell) ~ "Complete", TRUE ~ 
                                    "Other"))
                                return(full_NGT)
                            }

```

```{r}

final_NGT<-generate_lowQC_matrix(file=file,
                                 complete_NGT=complete_NGT,
                                 NGT_to_fill=maximal_NGT)
```

Now we want to enumerate how many clones are present by identifying the abundance of genetically identical cells.  We use the following clone naming convention, where left to right reads in the order of bulk VAF, and each genotype is separated by an underscore ("_").  So a clone 1_0_1_0 would be heterozygous for the 1st and 3rd most abundant mutations, and WT for the 2nd and 4th most abundant.  This function returns a list with three slots: Clones, NGT, and Architecture.  The replicates argument is used to determine how many rounds of resampling should be performed to establish a 95% confidence interval on the abundance of a particular clone.
```{r}
enumerate_clones_TR <- function (NGT, variant_metadata, replicates = 100) 
{
    bulk_VAF_order <- NGT %>% dplyr::select(!c(.data$Cell, .data$Group)) %>% 
        colSums %>% sort(decreasing = TRUE) %>% names
    NGT_to_clone <- NGT[, c("Cell", "Group", bulk_VAF_order)] %>% 
        tidyr::unite("Clone", tidyselect::all_of(bulk_VAF_order), 
            sep = "_", remove = FALSE)
    if ("Group" %in% colnames(final_NGT)) {
        clonal_abundance <- NGT_to_clone %>% dplyr::group_by(Group) %>% 
            dplyr::count(.data$Clone, name = "Count") %>% dplyr::arrange(.data$Count) %>% 
            tidyr::pivot_wider(id_cols = .data$Clone, names_from = .data$Group, 
                values_from = .data$Count) %>% dplyr::mutate(Complete = ifelse(is.na(.data$Complete), 
            0, .data$Complete)) %>% dplyr::mutate(Other = ifelse(is.na(.data$Other), 
            0, .data$Other)) %>% dplyr::group_by(.data$Clone) %>% 
            dplyr::mutate(Count = sum(.data$Other, .data$Complete)) %>% 
            dplyr::ungroup()
    }
    else {
        clonal_abundance <- NGT_to_clone %>% dplyr::count(.data$Clone, 
            name = "Count") %>% dplyr::arrange(.data$Count)
    }
    resample_fun <- function(data) {
        x <- data[sample(x = 1:nrow(data), replace = TRUE), ]
        return(as.matrix(x %>% dplyr::count(.data$Clone, name = "Count") %>% 
            dplyr::arrange(.data$Count)))
    }
    test <- replicate(n = replicates, resample_fun(NGT_to_clone), 
        simplify = "array")
    if (class(test) == "list") {
        y <- setNames(lapply(test, data.frame), 1:replicates)
    }
    else if (class(test) == "array") {
        y <- setNames(apply(test, 3, data.frame), 1:replicates)
    }
    y %<>% purrr::imap(~set_names(.x, c("Clone", .y))) %>% purrr::reduce(dplyr::full_join, 
        by = "Clone")
    y[is.na(y)] <- 0
    z <- data.frame(t(apply(y %>% dplyr::select(-.data$Clone), 
        1, function(p) {
            stats::quantile(as.numeric(p), probs = c(0.025, 0.975))
        })), Clone = y$Clone)
    clonal_abundance_boot_CI <- data.frame(dplyr::inner_join(data.frame(clonal_abundance), 
        z, by = "Clone"))%>% rename("Other" = "n_Other", "Complete" = "n_Complete","X2.5." = "LCI", "X97.5." = "UCI")
    clonal_architecture <- NGT_to_clone %>% dplyr::select(!c(.data$Cell, 
        .data$Group)) %>% dplyr::distinct() %>% tidyr::pivot_longer(cols = !.data$Clone, 
        names_to = "id", values_to = "Genotype") %>% dplyr::mutate(Genotype = dplyr::case_when(Genotype == 
        3 ~ "error", Genotype == 0 ~ "WT", Genotype == 1 ~ "Heterozygous", 
        Genotype == 2 ~ "Homozygous", TRUE ~ "error")) %>% dplyr::inner_join(variant_metadata %>% 
        dplyr::select(.data$id, .data$AA), by = "id") %>% dplyr::mutate(AA = factor(AA, 
        levels = as.character(final_variant_info$AA)))
    if (any(clonal_architecture$Genotype == "error")) {
        "something went wrong"
    }
    return(list(Clones = clonal_abundance_boot_CI, NGT = NGT_to_clone, 
        Architecture = clonal_architecture))
}

```

Now we enumerate clones over 500 replicates, using the `final_NGT` and `final_variant_info` as input. 
```{r}

final_sample_summary<- enumerate_clones_TR( NGT= final_NGT,
                                            variant_metadata=final_variant_info,
                                            replicates = 500)

```

With the clones enumerated, we can now aggregate the median read depth, genotype quality and allele dropout per clone.  We overwrite this into the 'Clones' slot into the final_sample_summary object. 
```{r}

quality_output<- function (file, filter = TRUE, input_variants, input_cells, NGT, 
    DP_cut = 10, AF_cut = 20, GQ_cut = 20) 
{
    all_variants <- rhdf5::h5read(file = file, name = "/assays/dna_variants/ca/id")
    select_variants <- match(input_variants, all_variants)
    all_cells <- rhdf5::h5read(file = file, name = "/assays/dna_variants/ra/barcode")
    select_cells <- match(input_cells, all_cells)
    AF <- rhdf5::h5read(file = file, name = "/assays/dna_variants/layers/AF", 
        index = list(select_variants, select_cells))
    DP <- rhdf5::h5read(file = file, name = "/assays/dna_variants/layers/DP", 
        index = list(select_variants, select_cells))
    GQ <- rhdf5::h5read(file = file, name = "/assays/dna_variants/layers/GQ", 
        index = list(select_variants, select_cells))
    ADO <- rhdf5::h5read(file = file, name = "/assays/dna_variants/ca/ado_rate")
    ADO_select <- which(ADO != "-1")
    NGT_ADO <- rhdf5::h5read(file = file, name = "/assays/dna_variants/layers/NGT", 
        index = list(ADO_select, select_cells))
    haplotype <- apply(NGT_ADO, 1, median)
    ADO_rate_by_cell <- data.frame(Cell = input_cells, ADO = apply(NGT_ADO, 
        2, function(x) {
            sum(x != haplotype)/length(x)
        }))
    filtered_long <- data.frame(setNames(data.frame(AF, variants = input_variants), 
        c(tidyselect::all_of(input_cells), "variants")) %>% tidyr::pivot_longer(cols = !c(variants), 
        names_to = "Cell", values_to = "AF"), data.frame(DP) %>% 
        tidyr::pivot_longer(cols = everything(), values_to = "DP") %>% 
        dplyr::select(DP), data.frame(GQ) %>% tidyr::pivot_longer(cols = everything(), 
        values_to = "GQ") %>% dplyr::select(GQ), NGT %>% dplyr::select(tidyselect::all_of(input_variants)) %>% 
        tidyr::pivot_longer(cols = everything(), values_to = "NGT") %>% 
        dplyr::select(NGT)) %>% dplyr::inner_join(ADO_rate_by_cell, 
        by = "Cell")
    if (filter == TRUE) {
        filtered_long %<>% dplyr::filter(DP >= DP_cut & GQ >= 
            GQ_cut) %>% dplyr::mutate(pass = dplyr::case_when(NGT == 
            1 & (AF > AF_cut) & (AF < (100 - AF_cut)) ~ "include", 
            NGT == 1 & ((AF <= AF_cut) | (AF >= (100 - AF_cut))) ~ 
                "exclude", NGT == 2 & AF >= (100 - AF_cut) ~ 
                "include", NGT == 2 & AF < (100 - AF_cut) ~ "exclude", 
            NGT == 0 & AF <= AF_cut ~ "include", NGT == 0 & AF > 
                AF_cut ~ "exclude", TRUE ~ "other")) %>% dplyr::filter(.data$pass == 
            "include")
    }
    return(filtered_long)
}


clone_QC <- function (final_sample_summary, file) 
              {
                  if (any(grepl("Group", colnames(final_sample_summary$Clones)))) {
                      stop(message("Clone QC already assessed"))
                  }
                  Cell_QC <- quality_output(file, filter = FALSE, input_variants = setdiff(colnames(final_sample_summary$NGT), 
                      c("Cell", "Group", "Clone")), input_cells = final_sample_summary$NGT$Cell, 
                      NGT = final_sample_summary$NGT, DP_cut = 10, AF_cut = 20, 
                      GQ_cut = 30) %>% dplyr::inner_join(final_sample_summary$NGT %>% 
                      dplyr::select(.data$Cell, .data$Group, .data$Clone), 
                      by = "Cell") %>% dplyr::group_by(Group, Clone, variants) %>% 
                      dplyr::summarize(AF_med = median(.data$AF), DP_med = median(.data$DP), 
                          GQ_med = median(.data$GQ), ADO_med = median(.data$ADO)) %>% 
                      dplyr::inner_join(final_sample_summary$Clones, by = "Clone")
              }


final_sample_summary$Clones<-clone_QC(final_sample_summary, file)

```


Now we'll generate a clonal bar plot to determine which mutational profile defines the largest clone.
```{r}

clonograph <- function (final_sample_summary, complete_only = FALSE, color_pal = "Reds") 
{
    consolidated_clonal_abundance <- final_sample_summary$Clones %>% 
        dplyr::group_by(Clone, Group) %>% dplyr::mutate(AF_med = mean(AF_med), 
        DP_med = mean(DP_med), GQ_med = mean(GQ_med)) %>% dplyr::select(!c(variants, 
        Count)) %>% dplyr::distinct() %>% dplyr::rowwise() %>% 
        dplyr::mutate(Count = ifelse(Group == "Other", n_Other, 
            n_Complete)) %>% dplyr::ungroup()
    if (complete_only == TRUE) {
        consolidated_clonal_abundance <- consolidated_clonal_abundance %>% 
            dplyr::filter(.data$Group == "Complete")
    }
    consolidated_clonal_abundance %<>% dplyr::arrange(.data$Count)
    clonal_architecture <- final_sample_summary$Architecture
    mutant_order <- setdiff(colnames(final_sample_summary$NGT), 
        c("Cell", "Clone", "Group"))
    clonal_architecture$Clone <- factor(clonal_architecture$Clone, 
        levels = unique(rev(consolidated_clonal_abundance$Clone)))
    consolidated_clonal_abundance$Clone <- factor(consolidated_clonal_abundance$Clone, 
        levels = levels(clonal_architecture$Clone))
    consolidated_clonal_abundance$Group <- factor(consolidated_clonal_abundance$Group, 
        levels = c("Complete", "Other"))
    gg_clonal_barplot <- ggplot(data = consolidated_clonal_abundance, 
        aes(x = Clone, y = Count, fill = Group)) + geom_bar(fun = "identity", 
        stat = "summary", position = "stack") + theme_classic(base_size = 7) + 
        scale_y_continuous(expand = c(0.01, 0)) + ylab("Cell Count") + 
        {
            if (complete_only == FALSE) {
                geom_errorbar(aes(ymin = LCI, ymax = UCI), width = 0.2)
            }
        } + scale_fill_manual(values = c(Other = "Grey70", Complete = RColorBrewer::brewer.pal(5, 
        tidyselect::all_of(color_pal))[5])) + theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(), axis.ticks.x = element_blank(), 
        axis.line.x = element_blank(), legend.position = "right", 
        plot.margin = unit(c(0, 0, 0, 0), "cm"))
    gg_heatmap <- ggplot(data = clonal_architecture, aes(x = Clone, 
        y = AA, fill = Genotype)) + geom_tile() + scale_fill_manual(values = c(WT = brewer.pal(7, 
        tidyselect::all_of(color_pal))[1], Heterozygous = brewer.pal(7, 
        tidyselect::all_of(color_pal))[3], Homozygous = brewer.pal(7, 
        tidyselect::all_of(color_pal))[6], Unknown = "grey50"), 
        name = "Genotype") + theme_classic(base_size = 7) + ylab("Mutation") + 
        scale_y_discrete(limits = rev(levels(clonal_architecture$AA))) + 
        theme(legend.position = "right", legend.direction = "vertical", 
            axis.text.x = element_blank(), axis.line = element_blank(), 
            axis.title.x = element_blank(), axis.ticks.x = element_blank(), 
            plot.margin = unit(c(0, 0, 0, 0), "cm"))
    gg_QC_heatmap <- ggplot(data = consolidated_clonal_abundance, 
        aes(x = Clone, y = Group, fill = ADO_med)) + geom_tile() + 
        colorspace::scale_fill_continuous_divergingx(palette = "RdBu", 
            mid = 0.1, rev = FALSE, na.value = "grey80", limits = c(0, 
                0.25)) + theme_classic(base_size = 7) + theme(legend.position = "right", 
        legend.direction = "horizontal", axis.text.x = element_blank(), 
        axis.line = element_blank(), axis.title.x = element_blank(), 
        axis.ticks.x = element_blank(), plot.margin = unit(c(0, 
            0, 0, 0), "cm"))
    gg_QC_heatmap_GQ <- ggplot(data = consolidated_clonal_abundance, 
        aes(x = Clone, y = Group, fill = GQ_med)) + geom_tile() + 
        colorspace::scale_fill_continuous_divergingx(palette = "RdBu", 
            mid = 30, rev = TRUE, na.value = "grey80", limits = c(0, 
                100)) + theme_classic(base_size = 7) + theme(legend.position = "right", 
        legend.direction = "horizontal", axis.text.x = element_blank(), 
        axis.line = element_blank(), axis.title.x = element_blank(), 
        axis.ticks.x = element_blank(), plot.margin = unit(c(0, 
            0, 0, 0), "cm"))
    gg_QC_heatmap_DP <- ggplot(data = consolidated_clonal_abundance, 
        aes(x = Clone, y = Group, fill = DP_med)) + geom_tile() + 
        colorspace::scale_fill_continuous_divergingx(palette = "RdBu", 
            mid = 10, rev = TRUE, na.value = "grey80", limits = c(0, 
                40)) + theme_classic(base_size = 7) + theme(legend.position = "right", 
        legend.direction = "horizontal", axis.text.x = element_blank(), 
        axis.line = element_blank(), axis.title.x = element_blank(), 
        axis.ticks.x = element_blank(), plot.margin = unit(c(0, 
            0, 0, 0), "cm"))
    return(plot_grid(gg_clonal_barplot, gg_heatmap, gg_QC_heatmap, 
        gg_QC_heatmap_GQ, gg_QC_heatmap_DP, ncol = 1, align = "v", 
        axis = "lr", rel_heights = c(1, 0.5, 0.25, 0.25, 0.25)))
}

```

```{r}

clonograph(final_sample_summary, complete_only = TRUE) #selecting cells with complete genotyping for each of the mutations

```

```{r}

print(required_variants)

```


Based on the clonal barplot, we know the that the biggest clone has heterozygous mutations in FLT3, DNMT3A, and RUNX1. We'll now subset the `filtered_NGT` to select cells that have this mutational profile, and will export this subset of data for inclusion in the synthetic multiplexing process. We similarly export an AF matrix containing this subset of cells. Below is information on which clones were exported for samples B-E:

Sample B: c(`chr2:25457243:G/A` == "1" & `chr15:90631934:C/T` == "1" & `chr21:36252954:A/C` == "1")
Sample C: c(`chr2:25457242:C/T` == "1" & `chr21:36252945:G/GCCC` == "1") 
Sample D: c`chr15:90631934:C/T` == "1" & `chr21:36231773:C/T` == "0") 
Sample E: c(`chr2:198267359:C/A` == "1" & `chr21:36231774:G/A` == "1")

```{r}

Sample_A_NGT<- filtered_NGT %>% 
               dplyr::filter(`chr2:25457242:C/T` == "1" & 
                             `chr13:28592642:C/G` == "1" & 
                             `chr21:36252994:T/TCC` == "1" ) 

             
Sample_A_AF <- filtered_AF %>% 
               dplyr::filter(Cell %in% Sample_A_NGT$Cell) %>% 
               dplyr::select(colnames(Sample_A_NGT))

  
dim(Sample_A_NGT)
dim(Sample_A_AF)

```


Now we'll pull SNPs from the h.sapiens ENSEMBL SNP mart, and format our list of variants to then identify SNPs that were genotyped in our dataset. This is first achieved below for coding SNPs, which are annotated and then filtered to remove pathogenic variants. We end up with a dataframe `coding_SNPs_final`, which has candidate SNPs to use for demultiplexing. 
```{r}
library(BSgenome.Hsapiens.UCSC.hg19)
library(SNPlocs.Hsapiens.dbSNP144.GRCh37)
library(biomaRt)

Sample_A_mutation_info <- data.frame(Bulk_VAF = apply(Sample_A_NGT %>% 
                                     dplyr::select(!.data$Cell), MARGIN = 2, function(x) {
                                     (sum(x, na.rm = TRUE)/(sum(!is.na(x)) * 2)) * 100
                                     }), GT_call_rate = apply(Sample_A_NGT %>% dplyr::select(!.data$Cell), 
                                     MARGIN = 2, function(x) {
                                     100 - (sum(is.na(x))/length(x) * 100)
                                     }), id = colnames(Sample_A_NGT)[colnames(Sample_A_NGT) !="Cell"])%>% 
                                     dplyr::inner_join(out, by = "id")

snp_mart <- useEnsembl(biomart="ENSEMBL_MART_SNP", 
                       host="grch37.ensembl.org", 
                       dataset="hsapiens_snp")

genome <- BSgenome.Hsapiens.UCSC.hg19
all_snps <- SNPlocs.Hsapiens.dbSNP144.GRCh37
seqlevelsStyle(genome) <- "NCBI"

position_coding<- final_mutation_info %>% dplyr::filter(Bulk_VAF > .01) %>% 
                                          dplyr::filter(GT_call_rate > 50) %>%
                                          dplyr::filter(LOCATION %in% c("coding")) %>%
                                          dplyr::filter(!id %in% required_variants) %>%
                                          dplyr::select(seqnames,start, end)

position_coding$seqnames<-gsub("chr","",position_coding$seqnames)
  names(position_coding)[names(position_coding)== "seqnames"]<- "CHR"

position_coding$start<- as.character(position_coding$start)
position_coding$end<- as.character(position_coding$end)

coding_positions <- GPos(seqnames = position_coding$CHR, pos = position_coding$start)
coding_SNPs <- snpsByOverlaps(all_snps, coding_positions, genome = genome)
coding_SNPs_df <- data.frame(chr_pos = start(coding_SNPs), mcols(coding_SNPs)[,c("RefSNP_id", "ref_allele", "alt_alleles")])


coding_SNPs_annotated<-  getBM(attributes=c("refsnp_source",
                                            'refsnp_id',
                                             'chr_name',
                                             'chrom_start',
                                             'chrom_end',
                                             "consequence_type_tv", 
                                             "clinical_significance"), filters = 'snp_filter', 
                                                                       values = coding_SNPs_df$RefSNP_id, 
                                                                       mart = snp_mart)

nonpath_coding_SNPs <- coding_SNPs_annotated[!grepl("pathogenic",coding_SNPs_annotated$clinical_significance),]
                        
coding_SNPs_final <- subset(Sample_A_mutation_info, start %in% nonpath_coding_SNPs$chrom_start)

```

This process is repeated to identify nonpathogenic intronic SNPs below. 
```{r}

position_intron <- final_mutation_info %>% dplyr::filter(LOCATION %in% c("intron")) %>%
                                           dplyr::filter(Bulk_VAF > .01) %>% 
                                           dplyr::filter(GT_call_rate > 50) %>%
                                           dplyr::select(seqnames.x,start.x, end.x)

position_intron$seqnames<-gsub("chr","",position_intron$seqnames)
  names(position_intron)[names(position_intron)== "seqnames"]<- "CHR"

position_intron$start<- as.character(position_intron$start)
position_intron$end<- as.character(position_intron$end)


genome <- BSgenome.Hsapiens.UCSC.hg19
all_snps <- SNPlocs.Hsapiens.dbSNP144.GRCh37


seqlevelsStyle(genome) <- "NCBI"

intron_positions <- GPos(seqnames = position_intron$CHR, pos = position_intron$start)

intron_SNPs <- snpsByOverlaps(all_snps, intron_positions, genome = genome)

intron_SNPs_df <- data.frame(chr_pos = start(intron_SNPs), mcols(intron_SNPs)[,c("RefSNP_id", "ref_allele", "alt_alleles")])

intron_SNPs_annotated<-  getBM(attributes=c("refsnp_source",
                                            "refsnp_id",
                                             "chr_name",
                                             "chrom_start",
                                             "chrom_end",
                                             "consequence_type_tv", 
                                             "clinical_significance"), filters = "snp_filter", 
                                                                       values = intron_SNPs_df$RefSNP_id, 
                                                                       mart = snp_mart)

unique(intron_SNPs_annotated$clinical_significance)

intron_SNPs_filtered <- intron_SNPs_annotated %>%  dplyr::filter(!duplicated(refsnp_id))

intron_SNPs_final <- subset(Sample_A_mutation_info, start.x %in% intron_SNPs_filtered$chrom_start)

```

Combine coding and intronic SNPs genotyped in this data set. This is then exported and used downstream in the synthetic multiplexing process.
```{r}

Sample_A_SNPs_all <- rbind(coding_SNPs_final, intron_SNPs_final)

```
